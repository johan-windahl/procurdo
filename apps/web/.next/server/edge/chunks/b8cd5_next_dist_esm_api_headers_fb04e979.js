(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["chunks/b8cd5_next_dist_esm_api_headers_fb04e979.js",9541,e=>{"use strict";e.s(["cookies",()=>g,"draftMode",()=>k,"headers",()=>v],9541),e.s([],66629),e.s(["cookies",()=>g],84439);var r=e.i(61583);e.i(9934);var t=e.i(9096);e.i(47255);var a=e.i(34136),n=e.i(66586),i=e.i(71250),o=e.i(25115),s=e.i(75275),c=e.i(97032),u=e.i(21221);let d={current:null},l="function"==typeof u.cache?u.cache:e=>e,h=console.warn;function f(e){return function(...r){h(e(...r))}}l(e=>{try{h(d.current)}finally{d.current=null}});var p=e.i(54794),b=e.i(49160);function g(){let e="cookies",u=a.workAsyncStorage.getStore(),d=i.workUnitAsyncStorage.getStore();if(u){if(d&&"after"===d.phase&&!(0,p.isRequestAPICallableInsideAfter)())throw Object.defineProperty(Error(`Route ${u.route} used "cookies" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "cookies" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`),"__NEXT_ERROR_CODE",{value:"E88",enumerable:!1,configurable:!0});if(u.forceStatic)return E(r.RequestCookiesAdapter.seal(new t.RequestCookies(new Headers({}))));if(u.dynamicShouldError)throw Object.defineProperty(new s.StaticGenBailoutError(`Route ${u.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`cookies\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`),"__NEXT_ERROR_CODE",{value:"E549",enumerable:!1,configurable:!0});if(d)switch(d.type){case"cache":let a=Object.defineProperty(Error(`Route ${u.route} used "cookies" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`),"__NEXT_ERROR_CODE",{value:"E398",enumerable:!1,configurable:!0});throw Error.captureStackTrace(a,g),u.invalidDynamicUsageError??=a,a;case"unstable-cache":throw Object.defineProperty(Error(`Route ${u.route} used "cookies" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "cookies" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`),"__NEXT_ERROR_CODE",{value:"E157",enumerable:!1,configurable:!0});case"prerender":var l=u,h=d;let n=m.get(h);if(n)return n;let i=(0,c.makeHangingPromise)(h.renderSignal,l.route,"`cookies()`");return m.set(h,i),i;case"prerender-client":let f="`cookies`";throw Object.defineProperty(new b.InvariantError(`${f} must not be used within a client component. Next.js should be preventing ${f} from being included in client components statically, but did not in this case.`),"__NEXT_ERROR_CODE",{value:"E693",enumerable:!1,configurable:!0});case"prerender-ppr":return(0,o.postponeWithTracking)(u.route,e,d.dynamicTracking);case"prerender-legacy":return(0,o.throwToInterruptStaticGeneration)(e,u,d);case"prerender-runtime":return(0,o.delayUntilRuntimeStage)(d,function(e){let r=m.get(e);if(r)return r;let t=Promise.resolve(e);return m.set(e,t),t}(d.cookies));case"private-cache":return E(d.cookies);case"request":return(0,o.trackDynamicDataInDynamicRender)(d),E((0,r.areCookiesMutableInCurrentPhase)(d)?d.userspaceMutableCookies:d.cookies)}}(0,n.throwForMissingRequestStore)(e)}e.i(89778);let m=new WeakMap;function E(e){let r=m.get(e);if(r)return r;let t=Promise.resolve(e);return m.set(e,t),Object.defineProperties(t,{[Symbol.iterator]:{value:e[Symbol.iterator]?e[Symbol.iterator].bind(e):y.bind(e)},size:{get:()=>e.size},get:{value:e.get.bind(e)},getAll:{value:e.getAll.bind(e)},has:{value:e.has.bind(e)},set:{value:e.set.bind(e)},delete:{value:e.delete.bind(e)},clear:{value:"function"==typeof e.clear?e.clear.bind(e):_.bind(e,t)},toString:{value:e.toString.bind(e)}}),t}function y(){return this.getAll().map(e=>[e.name,e]).values()}function _(e){for(let e of this.getAll())this.delete(e.name);return e}f(function(e,r){let t=e?`Route "${e}" `:"This route ";return Object.defineProperty(Error(`${t}used ${r}. \`cookies()\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`),"__NEXT_ERROR_CODE",{value:"E223",enumerable:!1,configurable:!0})}),e.s(["headers",()=>v],87478);var R=e.i(3042);function v(){let e="headers",r=a.workAsyncStorage.getStore(),t=i.workUnitAsyncStorage.getStore();if(r){if(t&&"after"===t.phase&&!(0,p.isRequestAPICallableInsideAfter)())throw Object.defineProperty(Error(`Route ${r.route} used "headers" inside "after(...)". This is not supported. If you need this data inside an "after" callback, use "headers" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`),"__NEXT_ERROR_CODE",{value:"E367",enumerable:!1,configurable:!0});if(r.forceStatic)return w(R.HeadersAdapter.seal(new Headers({})));if(t)switch(t.type){case"cache":{let e=Object.defineProperty(Error(`Route ${r.route} used "headers" inside "use cache". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`),"__NEXT_ERROR_CODE",{value:"E304",enumerable:!1,configurable:!0});throw Error.captureStackTrace(e,v),r.invalidDynamicUsageError??=e,e}case"private-cache":{let e=Object.defineProperty(Error(`Route ${r.route} used "headers" inside "use cache: private". Accessing "headers" inside a private cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`),"__NEXT_ERROR_CODE",{value:"E742",enumerable:!1,configurable:!0});throw Error.captureStackTrace(e,v),r.invalidDynamicUsageError??=e,e}case"unstable-cache":throw Object.defineProperty(Error(`Route ${r.route} used "headers" inside a function cached with "unstable_cache(...)". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use "headers" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`),"__NEXT_ERROR_CODE",{value:"E127",enumerable:!1,configurable:!0})}if(r.dynamicShouldError)throw Object.defineProperty(new s.StaticGenBailoutError(`Route ${r.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`headers\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`),"__NEXT_ERROR_CODE",{value:"E525",enumerable:!1,configurable:!0});if(t)switch(t.type){case"prerender":case"prerender-runtime":var u=r,d=t;let a=O.get(d);if(a)return a;let n=(0,c.makeHangingPromise)(d.renderSignal,u.route,"`headers()`");return O.set(d,n),n;case"prerender-client":let i="`headers`";throw Object.defineProperty(new b.InvariantError(`${i} must not be used within a client component. Next.js should be preventing ${i} from being included in client components statically, but did not in this case.`),"__NEXT_ERROR_CODE",{value:"E693",enumerable:!1,configurable:!0});case"prerender-ppr":return(0,o.postponeWithTracking)(r.route,e,t.dynamicTracking);case"prerender-legacy":return(0,o.throwToInterruptStaticGeneration)(e,r,t);case"request":return(0,o.trackDynamicDataInDynamicRender)(t),w(t.headers)}}(0,n.throwForMissingRequestStore)(e)}let O=new WeakMap;function w(e){let r=O.get(e);if(r)return r;let t=Promise.resolve(e);return O.set(e,t),Object.defineProperties(t,{append:{value:e.append.bind(e)},delete:{value:e.delete.bind(e)},get:{value:e.get.bind(e)},has:{value:e.has.bind(e)},set:{value:e.set.bind(e)},getSetCookie:{value:e.getSetCookie.bind(e)},forEach:{value:e.forEach.bind(e)},keys:{value:e.keys.bind(e)},values:{value:e.values.bind(e)},entries:{value:e.entries.bind(e)},[Symbol.iterator]:{value:e[Symbol.iterator].bind(e)}}),t}f(function(e,r){let t=e?`Route "${e}" `:"This route ";return Object.defineProperty(Error(`${t}used ${r}. \`headers()\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`),"__NEXT_ERROR_CODE",{value:"E277",enumerable:!1,configurable:!0})}),e.s(["draftMode",()=>k],12428);var S=e.i(15528);function k(){let e=a.workAsyncStorage.getStore(),r=i.workUnitAsyncStorage.getStore();switch((!e||!r)&&(0,n.throwForMissingRequestStore)("draftMode"),r.type){case"prerender-runtime":return(0,o.delayUntilRuntimeStage)(r,j(r.draftMode,e));case"request":return j(r.draftMode,e);case"cache":case"private-cache":case"unstable-cache":let t=(0,n.getDraftModeProviderForCacheScope)(e,r);if(t)return j(t,e);case"prerender":case"prerender-client":case"prerender-ppr":case"prerender-legacy":return j(null,e);default:return r}}function j(e,r){let t,a=e??T,n=D.get(a);return n||(t=function(e){let r=new P(e),t=Promise.resolve(r);return Object.defineProperty(t,"isEnabled",{get:()=>r.isEnabled,enumerable:!0,configurable:!0}),t.enable=r.enable.bind(r),t.disable=r.disable.bind(r),t}(e),D.set(a,t),t)}let T={},D=new WeakMap;class P{constructor(e){this._provider=e}get isEnabled(){return null!==this._provider&&this._provider.isEnabled}enable(){$("draftMode().enable()",this.enable),null!==this._provider&&this._provider.enable()}disable(){$("draftMode().disable()",this.disable),null!==this._provider&&this._provider.disable()}}function $(e,r){let t=a.workAsyncStorage.getStore(),n=i.workUnitAsyncStorage.getStore();if(t){if((null==n?void 0:n.phase)==="after")throw Object.defineProperty(Error(`Route ${t.route} used "${e}" inside \`after\`. The enabled status of draftMode can be read inside \`after\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`),"__NEXT_ERROR_CODE",{value:"E348",enumerable:!1,configurable:!0});if(t.dynamicShouldError)throw Object.defineProperty(new s.StaticGenBailoutError(`Route ${t.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`),"__NEXT_ERROR_CODE",{value:"E553",enumerable:!1,configurable:!0});if(n)switch(n.type){case"cache":case"private-cache":{let a=Object.defineProperty(Error(`Route ${t.route} used "${e}" inside "use cache". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`),"__NEXT_ERROR_CODE",{value:"E246",enumerable:!1,configurable:!0});throw Error.captureStackTrace(a,r),t.invalidDynamicUsageError??=a,a}case"unstable-cache":throw Object.defineProperty(Error(`Route ${t.route} used "${e}" inside a function cached with "unstable_cache(...)". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`),"__NEXT_ERROR_CODE",{value:"E259",enumerable:!1,configurable:!0});case"prerender":case"prerender-runtime":{let r=Object.defineProperty(Error(`Route ${t.route} used ${e} without first calling \`await connection()\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`),"__NEXT_ERROR_CODE",{value:"E126",enumerable:!1,configurable:!0});return(0,o.abortAndThrowOnSynchronousRequestDataAccess)(t.route,e,r,n)}case"prerender-client":let a="`draftMode`";throw Object.defineProperty(new b.InvariantError(`${a} must not be used within a client component. Next.js should be preventing ${a} from being included in client components statically, but did not in this case.`),"__NEXT_ERROR_CODE",{value:"E693",enumerable:!1,configurable:!0});case"prerender-ppr":return(0,o.postponeWithTracking)(t.route,e,n.dynamicTracking);case"prerender-legacy":n.revalidate=0;let i=Object.defineProperty(new S.DynamicServerError(`Route ${t.route} couldn't be rendered statically because it used \`${e}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`),"__NEXT_ERROR_CODE",{value:"E558",enumerable:!1,configurable:!0});throw t.dynamicUsageDescription=e,t.dynamicUsageStack=i.stack,i;case"request":(0,o.trackDynamicDataInDynamicRender)(n)}}}f(function(e,r){let t=e?`Route "${e}" `:"This route ";return Object.defineProperty(Error(`${t}used ${r}. \`draftMode()\` should be awaited before using its value. Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`),"__NEXT_ERROR_CODE",{value:"E377",enumerable:!1,configurable:!0})}),e.i(66629),e.i(84439),e.i(87478),e.i(12428)}]);

//# sourceMappingURL=b8cd5_next_dist_esm_api_headers_fb04e979.js.map